<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Crypto Tools</title>
  <link rel="manifest" href="/manifest.json">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Crypto Tools">
  <link rel="apple-touch-icon" href="/icons/icon-180.png">
  <style>
    :root { --bg:#0b0b0c; --card:#141416; --fg:#f3f4f6; --muted:#9ca3af; --brand:#0b79d0; --up:#16a34a; --down:#ef4444; --zoneR:rgba(239,68,68,.16); --zoneRBorder:rgba(239,68,68,.45); --zoneS:rgba(34,197,94,.16); --zoneSBorder:rgba(34,197,94,.45); }
    * { box-sizing: border-box; }
    body { font-family: -apple-system, system-ui, Helvetica, Arial, sans-serif; margin: 0; background: var(--bg); color: var(--fg); }
    nav { display: flex; position: sticky; top: 0; background: #111; border-bottom: 1px solid #222; z-index: 5; }
    nav button { flex: 1; padding: 12px; background: transparent; color: var(--fg); border: none; font-weight: 600; }
    nav button.active { background: #1b1c1f; }
    .tab { display: none; padding: 16px; }
    .tab.active { display: block; }
    .card { background: var(--card); border-radius: 18px; box-shadow: 0 8px 30px rgba(0,0,0,.25); padding: 16px; }
    label { display:block; font-size: 13px; color: var(--muted); margin-top: 8px; }
    input, select { width: 100%; padding: 10px 12px; border-radius: 12px; border: 1px solid #2a2c30; background: #0f1012; color: var(--fg); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .btn { background: var(--brand); color: #fff; padding: 12px; border: none; border-radius: 12px; font-weight: 700; width: 100%; margin-top: 12px; }
    .result { margin-top: 12px; font-weight: 700; line-height: 1.5; }
    .kv { display:flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px dashed #2a2c30; }
    .tfbar { display:flex; gap:8px; flex-wrap: wrap; margin: 8px 0 12px; }
    .tfbar button { padding:8px 10px; border-radius: 10px; border:1px solid #2a2c30; background:#0f1012; color:var(--fg); font-weight:700; }
    .tfbar button.active { border-color: var(--brand); outline: 0; }
    #srCanvas { width: 100%; height: 360px; display:block; border-radius: 12px; background: #0e0f12; }
    #srStatus { color: var(--muted); font-size: 12px; margin-top: 6px; }
  </style>
</head>
<body>
  <nav>
    <button id="btnMargin" class="active">Margin Calc</button>
    <button id="btnSR">S/R Zones</button>
  </nav>

  <!-- Simple Margin Calculator (inputs first, outputs after Calculate) -->
  <div id="marginTab" class="tab active">
    <div class="card">
      <h2 style="margin:0 0 8px">Margin Calculator</h2>

      <!-- Inputs -->
      <div class="row">
        <div>
          <label>Account Size (USD)</label>
          <input id="accountSize" type="number" placeholder="e.g., 100" inputmode="decimal">
        </div>
        <div>
          <label>Risk %</label>
          <input id="riskPercent" type="number" placeholder="e.g., 5" inputmode="decimal">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Entry Price (USD)</label>
          <input id="entryPrice" type="number" placeholder="e.g., 118100" inputmode="decimal">
        </div>
        <div>
          <label>Distance $</label>
          <input id="distance" type="number" placeholder="e.g., 1300" inputmode="decimal">
        </div>
      </div>

      <div class="row">
        <div>
          <label>Leverage (×)</label>
          <input id="leverage" type="number" value="5" min="1" step="1" inputmode="numeric">
        </div>
        <div>
          <label>Risk/Reward Ratio</label>
          <input id="rr" type="number" placeholder="e.g., 2" inputmode="decimal">
        </div>
      </div>

      <button class="btn" id="btnCalc">Calculate</button>

      <!-- Outputs (only after Calculate) -->
      <div id="outputs" class="result" style="display:none">
        <div class="kv"><span>Potential Loss</span><span id="outLoss">$0.00</span></div>
        <div class="kv"><span>Position Size</span><span id="outPos">$0.00</span></div>
        <div class="kv"><span>Stop Loss</span><span id="outSL">$0.00</span></div>
        <div class="kv"><span>Take Profit</span><span id="outTP">$0.00</span></div>
      </div>
    </div>
  </div>

  <!-- S/R Zones CHART-ONLY (timeframe buttons, no inputs) -->
  <div id="srTab" class="tab">
    <div class="card">
      <h2 style="margin:0 8px 2px 0; display:flex; align-items:center; gap:8px">BTC S/R Chart <small style="color:#9ca3af; font-weight:400">(auto: last N recent candles)</small></h2>
      <div class="tfbar" id="tfbar"></div>
      <canvas id="srCanvas"></canvas>
      <div id="srStatus"></div>
    </div>
  </div>

<script>
  // Tabs
  const tabs = { margin: document.getElementById('marginTab'), sr: document.getElementById('srTab') };
  document.getElementById('btnMargin').onclick = () => switchTab('margin');
  document.getElementById('btnSR').onclick = () => switchTab('sr');
  function switchTab(tab) {
    document.querySelectorAll('nav button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    if (tab === 'margin') { document.getElementById('btnMargin').classList.add('active'); tabs.margin.classList.add('active'); }
    if (tab === 'sr') { document.getElementById('btnSR').classList.add('active'); tabs.sr.classList.add('active'); }
  }

  // Utils
  const $ = id => document.getElementById(id);
  const fmt = (n, d=2) => Number(n).toLocaleString(undefined,{maximumFractionDigits:d, minimumFractionDigits:d});

  // Calculator (exact spec)
  document.getElementById('btnCalc').addEventListener('click', ()=>{
    const acct = parseFloat($('accountSize').value);
    const riskPct = parseFloat($('riskPercent').value);
    const entry = parseFloat($('entryPrice').value);
    const dist = parseFloat($('distance').value);
    const lev = Math.max(1, parseInt($('leverage').value)||1);
    const rr = parseFloat($('rr').value);

    if ([acct,riskPct,entry,dist,lev,rr].some(x=>isNaN(x))) { alert('Fill all inputs.'); return; }
    if (acct<=0 || riskPct<=0 || entry<=0 || dist<=0 || lev<=0 || rr<=0) { alert('All values must be positive.'); return; }

    const potentialLoss = acct * (riskPct/100);
    const positionSize = (potentialLoss * entry) / (dist * lev);
    const stopLoss = entry - dist;        // LONG orientation
    const takeProfit = entry + (dist * rr);

    $('outLoss').textContent = `$${fmt(potentialLoss,2)}`;
    $('outPos').textContent  = `$${fmt(positionSize,2)}`;
    $('outSL').textContent   = `$${fmt(stopLoss,2)}`;
    $('outTP').textContent   = `$${fmt(takeProfit,2)}`;

    $('outputs').style.display = '';
  });

  // --- S/R chart (no inputs) ---
  const TFs = ['15m','30m','1h','4h','1d','1w','1M'];
  const defaultWindow = tf => ({ '15m':300,'30m':300,'1h':300,'2h':300,'4h':300,'6h':240,'8h':240,'12h':240,'1d':200,'3d':150,'1w':104,'1M':60 }[tf] || 300);
  const proxMap = { '15m':0.05,'30m':0.07,'1h':0.12,'4h':0.15,'1d':0.20,'1w':0.30,'1M':0.40 };

  async function fetchKlines(symbol, interval, limit=1000) {
    const endpoints = [
      `https://data-api.binance.vision/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`,
      `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`,
      `https://api.binance.us/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`
    ];
    let lastErr;
    for (const url of endpoints) {
      try { const res = await fetch(url, { cache: 'no-store', mode: 'cors' }); if (res.ok) return await res.json(); lastErr = new Error(`HTTP ${res.status}`);} catch(e){ lastErr=e; }
    }
    throw lastErr || new Error('All endpoints failed');
  }
  function computeATR(klines, period=14){
    const highs=klines.map(c=>+c[2]); const lows=klines.map(c=>+c[3]); const closes=klines.map(c=>+c[4]);
    const TR=[]; for(let i=0;i<highs.length;i++){ if(i===0){TR.push(highs[i]-lows[i]); continue;} const pc=closes[i-1]; TR.push(Math.max(highs[i]-lows[i], Math.abs(highs[i]-pc), Math.abs(lows[i]-pc))); }
    const n=Math.min(period,TR.length); return TR.slice(-n).reduce((a,b)=>a+b,0)/n;
  }
  function findSwingPoints(klines, window=3){ const H=klines.map(c=>+c[2]); const L=klines.map(c=>+c[3]); const hi=[],lo=[]; for(let i=window;i<klines.length-window;i++){ const h=H[i], l=L[i]; let isMax=true,isMin=true; for(let j=i-window;j<=i+window;j++){ if(H[j]>h) isMax=false; if(L[j]<l) isMin=false; } if(isMax) hi.push(h); if(isMin) lo.push(l);} return {swingsHi:hi,swingsLo:lo}; }
  function clusterLevels(levels,tol){ levels.sort((a,b)=>a-b); const clusters=[]; let cur=[]; for(const lv of levels){ if(!cur.length||Math.abs(lv-cur[cur.length-1])<=tol){cur.push(lv);} else {clusters.push(cur.slice()); cur=[lv];}} if(cur.length) clusters.push(cur); return clusters.map(arr=>({min:Math.min(...arr),max:Math.max(...arr),count:arr.length,mid:(Math.min(...arr)+Math.max(...arr))/2})); }

  function proximityFilter(zs, close, pct){
    const band = close*pct; const out = zs.filter(z=>Math.abs(z.mid-close)<=band); return out.length? out : zs; }

  function buildTFButtons(){
    const bar = $('tfbar'); bar.innerHTML = '';
    TFs.forEach(tf=>{ const b=document.createElement('button'); b.textContent=tf; b.dataset.tf=tf; b.onclick=()=>renderSR(tf); bar.appendChild(b); });
  }
  function setActiveTF(tf){ document.querySelectorAll('#tfbar button').forEach(b=> b.classList.toggle('active', b.dataset.tf===tf)); }

  async function renderSR(tf){
    setActiveTF(tf); const status=$('srStatus'); status.textContent = `Loading ${tf}…`;
    try{
      const dataAll = await fetchKlines('BTCUSDT', tf==='1Y'?'1M':tf, 1000);
      const data = dataAll.slice(-Math.min(defaultWindow(tf), dataAll.length));
      const atr = computeATR(data,14);
      const {swingsHi,swingsLo} = findSwingPoints(data,3);
      const tol = Math.max(atr*0.5, 5);
      let res = clusterLevels(swingsHi,tol).sort((a,b)=>b.mid-a.mid);
      let sup = clusterLevels(swingsLo,tol).sort((a,b)=>a.mid-b.mid);
      const close = +data[data.length-1][4];
      const prox = proxMap[tf] ?? 0.15; // default
      res = proximityFilter(res, close, prox);
      sup = proximityFilter(sup, close, prox);
      drawChart('srCanvas', data, sup, res, close);
      status.textContent = `BTCUSDT • ${tf} • Close $${fmt(close,2)} • ATR(14) $${fmt(atr,2)}`;
    } catch(err){ status.textContent = 'Error: '+err.message; }
  }

  function drawChart(canvasId, kl, supZones, resZones, close){
    const canvas = $(canvasId); const dpr = window.devicePixelRatio || 1;
    const styleH = parseInt(getComputedStyle(canvas).height); const styleW = canvas.clientWidth;
    canvas.width = Math.max(300, styleW) * dpr; canvas.height = Math.max(220, styleH) * dpr;
    const ctx = canvas.getContext('2d'); ctx.scale(dpr,dpr);
    const W = canvas.width/dpr, H = canvas.height/dpr; const pad = 12; const plotL = pad, plotR = W - pad, plotT = pad, plotB = H - pad; const PW = plotR-plotL, PH = plotB-plotT;

    // derive price range (consider zones + candles)
    const highs = kl.map(c=>+c[2]); const lows = kl.map(c=>+c[3]);
    let pmin = Math.min(...lows), pmax = Math.max(...highs);
    [...supZones, ...resZones].forEach(z=>{ pmin = Math.min(pmin, z.min); pmax = Math.max(pmax, z.max); });
    const padPx = (pmax-pmin)*0.08 || 10; pmin -= padPx; pmax += padPx;
    const yFor = p => plotT + (pmax - p) * PH / (pmax - pmin || 1);

    // background
    ctx.fillStyle = '#0e0f12'; ctx.fillRect(0,0,W,H);

    // grid lines
    ctx.strokeStyle = '#1f2328'; ctx.lineWidth = 1; ctx.setLineDash([2,4]);
    for(let i=0;i<=4;i++){ const y = plotT + (PH*i/4); ctx.beginPath(); ctx.moveTo(plotL, y); ctx.lineTo(plotR, y); ctx.stroke(); }
    ctx.setLineDash([]);

    // zones first (under candles)
    function drawZone(z, colorFill, colorStroke){
      const y1 = yFor(z.max), y2 = yFor(z.min); ctx.fillStyle = colorFill; ctx.fillRect(plotL, y1, PW, Math.max(1, y2-y1));
      ctx.strokeStyle = colorStroke; ctx.lineWidth = 1; ctx.strokeRect(plotL, y1, PW, Math.max(1, y2-y1));
      // price label on right
      ctx.fillStyle = '#cbd5e1'; ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto';
      const label = `$${fmt(z.min,0)}–$${fmt(z.max,0)}`;
      ctx.fillText(label, plotR - ctx.measureText(label).width, Math.max(plotT+12, y1+12));
    }
    supZones.slice(0,4).forEach(z=> drawZone(z, getComputedStyle(document.documentElement).getPropertyValue('--zoneS'), getComputedStyle(document.documentElement).getPropertyValue('--zoneSBorder')));
    resZones.slice(0,4).forEach(z=> drawZone(z, getComputedStyle(document.documentElement).getPropertyValue('--zoneR'), getComputedStyle(document.documentElement).getPropertyValue('--zoneRBorder')));

    // candles
    const n = kl.length; const cw = Math.max(2, Math.floor(PW / n * 0.8)); const gap = Math.max(1, Math.floor(PW / n * 0.2));
    let x = plotL + Math.max(0, PW - (cw+gap)*n);
    ctx.lineWidth = 1;
    for(const c of kl){
      const o=+c[1], h=+c[2], l=+c[3], cl=+c[4];
      const yO=yFor(o), yH=yFor(h), yL=yFor(l), yC=yFor(cl);
      // wick
      ctx.strokeStyle = '#9ca3af'; ctx.beginPath(); ctx.moveTo(x+cw/2, yH); ctx.lineTo(x+cw/2, yL); ctx.stroke();
      // body
      const up = cl>=o; ctx.fillStyle = up? getComputedStyle(document.documentElement).getPropertyValue('--up') : getComputedStyle(document.documentElement).getPropertyValue('--down');
      const bodyY = Math.min(yO, yC); const bodyH = Math.max(1, Math.abs(yC - yO));
      ctx.fillRect(x, bodyY, cw, bodyH);
      x += cw + gap;
    }

    // last close line
    ctx.strokeStyle = '#6b7280'; ctx.setLineDash([6,6]); ctx.beginPath(); ctx.moveTo(plotL, yFor(close)); ctx.lineTo(plotR, yFor(close)); ctx.stroke(); ctx.setLineDash([]);

    // border
    ctx.strokeStyle = '#222'; ctx.strokeRect(plotL, plotT, PW, PH);
  }

  // build buttons & initial render
  function initTFUI(){
    const bar = $('tfbar');
    TFs.forEach(tf=>{ const b=document.createElement('button'); b.textContent=tf; b.dataset.tf=tf; b.onclick=()=>renderSR(tf); bar.appendChild(b); });
    renderSR('1h');
  }

  // handle resize
  window.addEventListener('resize', ()=>{ const active = document.querySelector('#tfbar button.active'); if (active) renderSR(active.dataset.tf); });

  // start
  initTFUI();

  // PWA
  if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('/sw.js'); }); }
</script>
</body>
</html>
